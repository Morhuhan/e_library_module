/* =======================================================
   0.  Расширения (по желанию)
--CREATE EXTENSION IF NOT EXISTS pgcrypto;
   =======================================================*/

/* =======================================================
   1.  Служебные справочники
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.roles (
    id   SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS public.users (
    id       SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    pass     VARCHAR(255)      NOT NULL,
    role_id  INT NOT NULL REFERENCES public.roles(id)
);

CREATE TABLE IF NOT EXISTS public.person (
    id          SERIAL PRIMARY KEY,
    first_name  VARCHAR(255) NOT NULL,
    last_name   VARCHAR(255) NOT NULL,
    middle_name VARCHAR(255)
);

/* =======================================================
   2.  Классификационные справочники
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.bbk (
    id          SERIAL PRIMARY KEY,
    bbk_abb     TEXT UNIQUE NOT NULL,
    description TEXT
);

CREATE TABLE IF NOT EXISTS public.udc (
    id          SERIAL PRIMARY KEY,
    udc_abb     TEXT UNIQUE NOT NULL,
    description TEXT
);

/* =======================================================
   3.  Книги, авторы, экземпляры
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.book (
    id                SERIAL PRIMARY KEY,
    title             TEXT,
    "type"            TEXT,
    edit              TEXT,
    edition_statement TEXT,
    phys_desc         TEXT,
    series            TEXT,
    local_index       TEXT
);

CREATE TABLE IF NOT EXISTS public.author (
    id        SERIAL PRIMARY KEY,
    full_name TEXT UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS public.book_author (
    book_id   INT NOT NULL REFERENCES public.book(id)   ON DELETE CASCADE,
    author_id INT NOT NULL REFERENCES public.author(id) ON DELETE CASCADE,
    PRIMARY KEY (book_id, author_id)
);

CREATE TABLE IF NOT EXISTS public.book_copy (
    id        SERIAL PRIMARY KEY,
    book_id   INT NOT NULL REFERENCES public.book(id) ON DELETE CASCADE,
    copy_info TEXT
);

/* =======================================================
   4.  RAW-таблицы (результат парсинга, без контроля целостности)
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.book_bbk_raw (
    book_id  INT NOT NULL REFERENCES public.book(id) ON DELETE CASCADE,
    bbk_code TEXT,
    PRIMARY KEY (book_id, bbk_code)
);

CREATE TABLE IF NOT EXISTS public.book_udc_raw (
    book_id  INT NOT NULL REFERENCES public.book(id) ON DELETE CASCADE,
    udc_code TEXT,
    PRIMARY KEY (book_id, udc_code)
);

/* =======================================================
   5.  Связи многие-ко-многим (валидные пары)
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.book_bbk (
    book_id INT NOT NULL REFERENCES public.book(id) ON DELETE CASCADE,
    bbk_id  INT NOT NULL REFERENCES public.bbk(id)  ON DELETE CASCADE,
    PRIMARY KEY (book_id, bbk_id)
);

CREATE TABLE IF NOT EXISTS public.book_udc (
    book_id INT NOT NULL REFERENCES public.book(id) ON DELETE CASCADE,
    udc_id  INT NOT NULL REFERENCES public.udc(id)  ON DELETE CASCADE,
    PRIMARY KEY (book_id, udc_id)
);

/* =======================================================
   6.  Публикационные сведения
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.publisher (
    id   SERIAL PRIMARY KEY,
    name TEXT UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS public.book_pub_place (
    id           SERIAL PRIMARY KEY,
    book_id      INT NOT NULL REFERENCES public.book(id)      ON DELETE CASCADE,
    publisher_id INT     REFERENCES public.publisher(id),
    city         TEXT,
    pub_year     INT,
    CONSTRAINT chk_place_not_empty
        CHECK (publisher_id IS NOT NULL OR city IS NOT NULL)
);

/* =======================================================
   7.  Учёт выдач
   =======================================================*/
CREATE TABLE IF NOT EXISTS public.borrow_record (
    id                  SERIAL PRIMARY KEY,
    book_copy_id        INT NOT NULL REFERENCES public.book_copy(id) ON DELETE CASCADE,
    person_id           INT NOT NULL REFERENCES public.person(id)    ON DELETE CASCADE,
    borrow_date         DATE DEFAULT CURRENT_DATE,
    due_date            DATE,
    return_date         DATE,
    issued_by_user_id   INT NOT NULL REFERENCES public.users(id)     ON DELETE CASCADE,
    accepted_by_user_id INT     REFERENCES public.users(id)          ON DELETE CASCADE,
    CONSTRAINT chk_return_consistency
        CHECK (
            (accepted_by_user_id IS NULL AND return_date IS NULL)
            OR
            (accepted_by_user_id IS NOT NULL AND return_date IS NOT NULL)
        )
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_borrowrecord_unique_open
    ON public.borrow_record (book_copy_id)
    WHERE return_date IS NULL;

/* =======================================================
   8.  Триггеры &laquo;не удалять, если выдано&raquo;
   =======================================================*/
CREATE OR REPLACE FUNCTION public.prevent_book_deletion_if_borrowed()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    IF EXISTS (
        SELECT 1
          FROM public.book_copy bc
          JOIN public.borrow_record br
            ON br.book_copy_id = bc.id
         WHERE bc.book_id = OLD.id
           AND br.return_date IS NULL
    ) THEN
        RAISE EXCEPTION 'Нельзя удалить книгу (id=%) — имеются выданные экземпляры.', OLD.id;
    END IF;
    RETURN OLD;
END;
$$;

CREATE OR REPLACE FUNCTION public.prevent_book_copy_deletion_if_borrowed()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    IF EXISTS (
        SELECT 1
          FROM public.borrow_record br
         WHERE br.book_copy_id = OLD.id
           AND br.return_date IS NULL
    ) THEN
        RAISE EXCEPTION 'Нельзя удалить экземпляр книги (copy id=%) — он выдан.', OLD.id;
    END IF;
    RETURN OLD;
END;
$$;

DROP TRIGGER IF EXISTS tr_prevent_book_deletion_if_borrowed ON public.book;
CREATE TRIGGER tr_prevent_book_deletion_if_borrowed
    BEFORE DELETE ON public.book
    FOR EACH ROW EXECUTE FUNCTION public.prevent_book_deletion_if_borrowed();

DROP TRIGGER IF EXISTS tr_prevent_book_copy_deletion_if_borrowed ON public.book_copy;
CREATE TRIGGER tr_prevent_book_copy_deletion_if_borrowed
    BEFORE DELETE ON public.book_copy
    FOR EACH ROW EXECUTE FUNCTION public.prevent_book_copy_deletion_if_borrowed();

/* =======================================================
   Готово!
   =======================================================*/